This will later become the documentation of the packet.
As of now, it is just a collection of stuff.

The Header of a CMC packet consists of:
16 bit source id
16 bit destination id
8 bit type flag:

Sync packet
Finish packet
Error packet
Ack packet
Challenge packet
Response packet
Data packet

The magic numbers corresponing to these types may vary during development and may be specified later.


A flag indicates, that this packet may have an option field attached to it.
The option fields are attached in the following order and size:
SYNC
FINISH
ERR
CHALLENGE
RESPONSE
KEY
ACK
DATA

Since the content of these field may change heavily, for content refer to CMC.h

Here comes a description of the commands and event in pseudocode:
NOTE: for better understanding, the actions are in the order, which makes 
the most sense, not the safes one.
A better order would be, to put message to the end of an action and only
signaling behind that. 
STATE changes should be done at beginning ????

Server init:
Set local_id, buf_len and keys set SYNC_STATE to CLOSED and MSGS_STATE to CLOSED, return

Server bind:
Does another socket have group_id?
  yes: raise error
  no: both STATES in CLOSED?
    yes: raise error
    no: set group_id, set SYNC_STATE to LISTEN and MSGS_STATE to ESTABLISHED, return

Server close:
TODO: needed and possible???

Server shutdown:
STATES in CLOSED?
  yes: raise error
  no: Send ferr packet with MCAST, set SYNC_STATE to CLOSED and MSGS_STATE to CLOSED, return

Server send:
MSGS_STATE in ESTABLISHED?
  no: raise error
  yes: hash message and encrypt message and hash, then send them, set MSGS_STATE to APCKPENDING and return

Server receive:
Is it a CHALLENGE or a KEY packet?
  yes: drop packet and return
Has any socket a matching group_id?
  no: drop packet and return
  yes: select that socket
Is it a SYNC packet?
  yes: Is SYNC_STATE in LISTEN:
    no: drop packet and return
    yes: Is nodes public key whitelisted?
      yes: generate challenge and send challenge to node, 
        set SYNC_RETRY and SYNC_TIMER, set SYNC_STATE to AUTH, then return
      no: send ferr with not_in_whitelist then return
Is it a RESPONSE packet?
  yes: Is SYNC_STATE in AUTH:
    no: drop packet and return
    yes: Is response correct?
      no: send err with incorrect_response, set SYNC_STATE to LISTEN and return
      yes: encrypt and send masterkey, set SYNC_STATE to LISTEN 
        signal user a connected and return
Is it a DATA packet?
  yes: is MSGS_STATE in ESTABLISHED?
    no: drop packet and return
    yes: Is MCAST set?
      yes: decrypt and signal data to user, resent data, then return
      no: Is destination_id your local_id?
        yes: decrypt and signal data to user, then return
        no: decrypt to update context, set hash,
          send packet, set MSGS_STATE to ACKPENGING adn return
Is it an ACK packet?
  yes: Is MSGS_STATE in ACKPENDING?
    no: drop packet and return
    yes: Is hash correct?
      no: send ferr with incorrect_checksum to dest and src, 
        set MSGS_STATE to ESTABLISHED and return NEEDED???
      yes: Is this node source?
        no: send ACK to src, set MSGS_STATE to ESTABLISHED and return
        yes: signal user sendDone, set MSGS_STATE to ESTABLISHED and return
//Is it a FINISH packet?
//  yes: MSGS_STATE in CLOSED?
//    yes: drop packet and return
//    no: signal user, that src has closed and return
Is it an ERR packet?
  yes: Error handling

Server Timer:
SYNC timer elapsed?
  yes: SYNC_STATE in AUTH?
    no: ignore and return
    yes: SYNC_RETRY elapsed?
      no: resend last Challenge
      yes: set SYNC_STATE to LISTEN, signal user failed connection attempt and return
MSGS timer elapsed?
  yes: MSGS_STATE in ACKPENDING?
    no: ignore
    yes: MSGS_RETRY elapsed?
      no: resent last message
      yes: was this node sender?
        yes: set SYNC_STATE to LISTEN, signal user failed sending and return
        no: send failure to src of last messagem set SYNC_STATE to LISTEN and return
      

Client init:
Set local_id, buf_len and keys, set SYN_STATE to CLOSED and MSGS_STATE to closed

Client connect:
Has another socket same group_id?
  yes: raise error
  no: send SYNC packet, set STATE to PRECONNECTION and return

Client close:
STATES in CLOSED:
  yes: raise error
  no: send FINISH packet to server, set both STATE to CLOSED and return

  
Server send:
MSGS_STATE in ESTABLISHED?
  no: raise error
  yes: hash message and encrypt message and hash, then send them, set MSGS_STATE to ACKPENDING and return
  
Client send:
  STATE in ESTABLISHED?
    no: raise error
    yes: hash message, encrypt hash and message, send them, 
      set STATE to ACKPENDING and return

Client receive:
Is it a SYNC or RESPONSE packet:
  Yes: drop and return
Has any socket a matching group_id?
  no: ignore and return
  yes: select that socket
Is it a CHALLENGE?
  Is STATE in PRECONNECTION:
    no: drop packet and return
    yes: solve the challenge, send it, set STATE to AUTH an return
Is it a KEY packet?
  STATE in PRECONNECTION or AUTH?
    no: ignore and return
    yes: decrypt and set master key, set STATE to ESTABLISHED, 
      signal connect done and return
Is it a DATA packet?
  STATE in ESTABLISHED?
    yes: Is it MCAST?
      yes: decrypt, signal data to user and return?
      no: This node is destionation?
        no: Decrypt and return
        yes: Decrypt, signal data to user, hash decrypted message, 
          send ACK, set STATE to ACKPENGING and return
  STATE in ACKPENDING?
    yes: Same message as last message send?
      no: signal error and return
      yes:
    
Is it an ACK packet?
  STATE in ACKPENDING?
    no: ignore and return
    yes: Is hash correct?
      no: send error with incorrect_checksum to src and dst, then return
      yes: signal user sendDone, set STATE to ESTABLISHED and return
//is it a FINNISH packet?
//  yes: STATE in CLOSED:
//    yes: ignore
//    no: set STATE to and closed, signal user and return
Is it and ERR packet?
  yes: error handling
  
Client Timer:
Timer elapsed?
  yes: 


